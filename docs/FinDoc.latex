\documentclass{article}
\usepackage{geometry}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumerate}
\pagestyle{fancy}
\fancyhead[L]{COMPSCI 4ZP6}
\fancyhead[R]{Emily Horsman <horsmane>, Tanner Ryan <ryant3>}

\newcommand{\name}{Telemetry\,}
\newcommand{\proto}{I\textsuperscript{2}C\,}

\title{Telemetry}
\author{Emily Horsman <horsmane@mcmaster.ca>, Tanner Ryan <ryant3@mcmaster.ca>}
\date{April 2020}

\begin{document}

\maketitle

\section*{Preamble}

\name saves significant development time for common embedded applications.

There is a large market of hardware peripherals which use an \proto bus to communicate with a computer.
They usually interface with an embedded device.\footnote{``Arduino-compatible'' microcontrollers are popular choices amongst hobbyists and industrial prototypers.}
These embedded controllers need to be flashed to change application logic and this often requires physical access.
There are thousands of such peripherals including sensors that measure temperature, moisture, colour, current, etc.
Hobbyists and industrial prototypers buy these sensors from distributors such as Adafruit and Sparkfun.
These distributors often share libraries that allow these sensors to be used with common embedded controllers with little development time.\footnote{e.g., For the SHT31 temperature and humidity sensor: \url{https://github.com/adafruit/Adafruit_SHT31}}
However, these libraries have a lot of redundancy amongst them and often contain technical tradeoffs.\footnote{e.g., calling functions which sleep the device instead of using an event loop that would allow other tasks to be performed.}

Writing a program for embedded controllers that reads and writes to \proto-based hardware peripherals traditionally involves three tasks:

\begin{enumerate}
\item Getting data off the \proto bus with sensor-specific protocols running in an ``application layer''.
\item Turning raw bytes from the sensor protocol into semantically sensible values. i.e., from bytes to a temperature reading in degrees Celsius.
\item Managing multiple sensors connected to the same \proto bus which are read and written to at various intervals.
\end{enumerate}

\name is a library for embedded devices that builds on an abstraction of hardware peripherals to simplify these tasks.

\begin{enumerate}
\item Generalizes interactions on the \proto bus to allow declarative configurations for new sensors to be written instead of application logic.
\item Decouples the application logic which deals with data semantics from the embedded device and its development environment.
    Developers will write a small program independent of the firmware flashed to embedded devices without needing to deal with low-level details.
    These programs can be written in any language and run on servers, instead of being written in the low-level systems languages that embedded devices typically use.\footnote{C and C++ are common choices for embedded controllers. Developers can use anything --- even something like Haskell --- for \name.}
\item Manages peripherals on an \proto bus without writing additional firmware logic.
    This includes logic for automatically discovering and processing data when a sensor is physically connected.
\end{enumerate}

This achieves meaningful outcomes for development teams.

\begin{enumerate}
\item Much less development time to work with data from sensors.
    Reduces prototyping to a ``plug-and-play'' experience.
\item Reduces skill specialization required for embedded development.
    Application logic can be written in any language without knowledge of embedded C++.
\item \name can be used as a pre-packaged firmware that can be uploaded to a compatible embedded device without changes.
    This allows you to physically connect sensors and immediately store data and consume data from a provided API.
\end{enumerate}

Emily Horsman and Tanner Ryan are responsible for this aspect of the project.

\section*{Software Requirements Specification}

\section*{Software Design Description}

\newpage

\section*{Code Guide}

\subsection*{Preamble}

Emily Horsman and Tanner Ryan are responsible for this aspect of the project.

\subsection*{Hardware/Software Requirements}

Language Summary: C++, Go, Haskell, JavaScript, Python

\subsubsection*{Hardware}

\begin{enumerate}
    \item An ESP32 or other Arduino-compatible microcontroller. We used a HUZZAH32 from Adafruit during development. \url{https://www.adafruit.com/product/3405}
\item \proto based sensors. We used an SHT31, LIS3DH, TCS34725, and AMG8833 during development to ensure our protocol works on a wide variety of sensors.
\end{enumerate}

\subsubsection*{Microcontroller Firmware}

\begin{enumerate}
\item C++11. This is the primary language the firmware is written in.
\item PlatformIO. This is a development toolchain to target the embedded hardware. \url{https://platformio.org}
\item nanopb v0.3.9.5. An implementation of Protocol Buffers designed for embedded systems. Included in this repository under \texttt{prototypes/lib/Nanopb}. \url{https://jpa.kapsi.fi/nanopb/}
\item MQTT Arduino Client. \url{https://github.com/knolleary/pubsubclient/}
\item Python 3.6. There is some rudimentary templating performed at compile-time for the provisioning web server running on the microcontroller. \url{https://www.python.org}
\end{enumerate}

\subsubsection*{Protocol and Networking}

\begin{enumerate}
\item \texttt{protoc} to compile and test Protocol Buffer schemas/messages. \url{https://developers.google.com/protocol-buffers}
\item VerneMQ. This is an MQTT broker. \url{https://vernemq.com}
\item RabbitMQ. This is an AMQP broker. \url{https://www.rabbitmq.com}
\item Docker. The backend, database, web server, and brokers are all provisioned with a Docker configuration file: \texttt{backend/Dockerfile}. \url{https://www.docker.com}
\end{enumerate}

\subsubsection*{Backend}

\begin{enumerate}
\item Go v1.14.2. This is the primary language the backend is written in. \url{https://golang.org}
\item Caddy v2. This is a web server which fronts the Go application server. \url{https://caddyserver.com}
\item PostgreSQL v12. Data from micro controllers is logged to a Postgres database. \url{https://www.postgresql.org}
\end{enumerate}

\subsubsection*{Peripheral Processors}

\begin{enumerate}
\item Haskell 2010. Peripheral processors can be written in any language with an AMQP library. This repo provides an example processor writte in Haskell (\texttt{sht31-controller/}) and includes a support library for other processors written in Haskell. \url{https://www.haskell.org}
\item Cabal to install Haskell dependencies in a standard way. \url{https://www.haskell.org/cabal/}
\item Aeson v1.4. \url{https://hackage.haskell.org/package/aeson}
\item base64-bytestring v1.1. \url{https://hackage.haskell.org/package/base64-bytestring}
\item AMQP client v0.19. \url{https://hackage.haskell.org/package/amqp}
\end{enumerate}

\subsubsection*{Dashboard}

\begin{enumerate}
\item JavaScript following modern ECMA standards is the primary language the dashboard is written in (along with HTML/CSS). One only needs a modern evergreen browser.
\item \texttt{npm} to install JavaScript packages. \url{https://www.npmjs.com}
\item React v16. \url{https://reactjs.org}
\item React Victory v34. \url{https://formidable.com/open-source/victory/}
\end{enumerate}

\subsection*{Completed Features and Details}

\begin{enumerate}
\item An abstraction for generalizing \proto sensors. This is reflected in the architecture of the entire repository. A primary artifact with detailed comments can be found in \texttt{protocol/telemetry.proto}. This is a Protocol Buffers definition for messages that generalize the behaviour of \proto sensors. A processor such as the one found in \texttt{sht31-controller/} can then specify the interaction with a sensor in a declarative fashion --- without writing new application logic or physically updating firmware. The low-level task of reading from the bus and understanding the sensors' protocol is decoupled from processing the data.
\end{enumerate}

\subsection*{A Tour of the Simplest Case}

Below is a description of the components involved in the simplest task of Telemetry: reading data from a sensor connected to a microcontroller, storing it in a database, and serving it through a REST and WebSockets API.
The primary feature of Telemetry is the architecture that allows \proto peripherals to be generalized and used without custom application logic.
The following tour is only showing one path of what this architecture allows.
It is a limited view that aims to highlight aspects of the codebase and how it works together --- not the entire scope of the project.

\begin{enumerate}
\item A microcontroller running the Telemetry firmware is powered on.
\item It broadcasts a WiFi access point and serves a web application.
    This allows users to provision the microcontroller with network connection information without needing to hard-code values in firmware and have physical access to the microcontroller.
    \texttt{prototypes/src/WiFiProvisioning.cpp}
\item A user provisions the microcontroller and the microcontroller connects to the given WiFi access point.
\item A sensor is plugged into the microcontroller.
    The sensor is automatically discovered.
    The Telemetry firmware consists of an event loop and state machine which poll the \proto bus for peripherals connecting and disconnecting --- \texttt{prototypes/src/I2CManager.cpp}.
    It also manages the firmware's multiple tasks by loosely emulating threads --- the microcontroller is not running an operating system that gives threads.
    We wrote a generic scheduler: \texttt{prototypes/src/Scheduler.cpp}.
\item A message is sent to the backend through the MQTT broker describing the connected sensor.
    \texttt{prototypes/src/MQTTManager.cpp}, \texttt{prototypes/src/TelemetryProtocol.cpp}
\item The backend asks the online processors if any are responsible for the described sensor. TODO
\item The responsible processor sends a declarative configuration for the sensor to the AMQP broker.
\item The backend delivers this to the appropriate microcontroller through the MQTT broker.
\item The firmware's runtime stores this configuration and will use it to poll data from the sensor.
        \texttt{prototypes/src/I2CRuntime.cpp}
\item The microcontroller reads data from the \proto bus and sends the raw bytes to the backend through MQTT.
\item The backend proliferates this to the appropriate processor through AMQP.
\item The processor converts the raw bytes to semantically correct data (such as a temperature value).
    \texttt{sht31-controller/Main.hs}
\item The processor sends this data to the backend through AMQP. \texttt{sht31-controller/Support.hs}
\item The backend writes this data to the database. \texttt{backend/controller/db/}
\item The backend pushes this new data to any open WebSocket connections. \texttt{backend/controller/api/websocket.go}
\item A dashboard with an open WebSocket connection reads this message and graphs the data over time.
    \texttt{dashboard/src/App.js}
\end{enumerate}

\subsection*{Statistics}

Using the tool \texttt{sloc} to quantify `significant' lines of code:

\begin{verbatim}
> sloc --exclude 'binary|docs|.*\.pio.*|.*vendor.*|Nanopb|.*node_modules.*' .

---------- Result ------------

  Physical :  5674
    Source :  4140
   Comment :  974
\end{verbatim}

\end{document}
