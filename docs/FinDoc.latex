\documentclass{article}
\usepackage{geometry}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumerate}
\usepackage{minted}
\usepackage{pdfpages}
\pagestyle{fancy}
\fancyhead[L]{COMPSCI 4ZP6}
\fancyhead[R]{Emily Horsman <horsmane>, Tanner Ryan <ryant3>}

\newcommand{\name}{Telemetry\,}
\newcommand{\proto}{I\textsuperscript{2}C\,}

\title{Telemetry}
\author{Emily Horsman <horsmane@mcmaster.ca>, Tanner Ryan <ryant3@mcmaster.ca>}
\date{April 30, 2020\\~\\COMPSCI 4ZP6\\Capstone Project\\McMaster University}

\begin{document}

\maketitle

\section*{Preamble}

\name saves significant development time for common embedded applications.
It offers a ``plug-and-play'' experience for \proto-based sensors, with immediate data logging and real-time streaming.
Refer to section ~\ref{sec:features} for a complete list of features.

There is a large market of hardware peripherals which use an \proto bus to communicate with a computer.
They usually interface with an embedded device.\footnote{``Arduino-compatible'' microcontrollers are popular choices amongst hobbyists and industrial prototypers.}
These embedded controllers need to be flashed to change application logic and this often requires physical access.
There are thousands of such peripherals including sensors that measure temperature, moisture, colour, current, etc.
Hobbyists and industrial prototypers buy these sensors from distributors such as Adafruit and Sparkfun.
These distributors often share libraries that allow these sensors to be used with common embedded controllers with little development time.\footnote{e.g., For the SHT31 temperature and humidity sensor: \url{https://github.com/adafruit/Adafruit_SHT31}}
However, these libraries have a lot of redundancy amongst them and choose unacceptable technical tradeoffs for complex projects.\footnote{e.g., calling functions which sleep the device instead of using an event loop that would allow other tasks to be performed.}

Writing a program for embedded controllers that reads and writes to \proto-based hardware peripherals traditionally involves three tasks:

\begin{enumerate}
\item Getting data off the \proto bus with sensor-specific protocols running in an ``application layer''.
\item Turning raw bytes from the sensor protocol into semantically sensible values. i.e., from bytes to a temperature reading in degrees Celsius.
\item Managing multiple sensors connected to the same \proto bus which are read and written to at various intervals.
\end{enumerate}

\name is a library for embedded devices that builds on an abstraction of hardware peripherals to simplify these tasks.

\begin{enumerate}
\item Generalizes interactions on the \proto bus to allow declarative configurations for new sensors to be written instead of application logic.
\item Decouples the application logic which deals with data semantics from the embedded device and its development environment.
    Developers will write a small program independent of the firmware flashed to embedded devices without needing to deal with low-level details.
    These programs can be written in any language and run on servers, instead of being written in the low-level systems languages that embedded devices typically use.\footnote{C and C++ are common choices for embedded controllers. Developers can use anything --- even something like Haskell --- for \name.}
\item Manages peripherals on an \proto bus without writing additional firmware logic.
    This includes logic for automatically discovering and processing data when a sensor is physically connected.
\end{enumerate}

This achieves meaningful outcomes for development teams.

\begin{enumerate}
\item Much less development time to work with data from sensors.
    Reduces prototyping to a ``plug-and-play'' experience.
\item Reduces skill specialization required for embedded development.
    Application logic can be written in any language without knowledge of embedded C++.
\item \name can be used as a pre-packaged firmware that can be uploaded to a compatible embedded device without changes.
    This allows you to physically connect sensors and immediately store data and consume data from a provided API.
\end{enumerate}

Emily Horsman and Tanner Ryan are responsible for this aspect of the project.\\

\section*{Acknowledgement}

We would like to thank our supervisors Dr. Jacques Carette <carette@mcmaster.ca> and Dr. Spencer Smith <smiths@mcmaster.ca> for their guidance throughout the project.
We would also like to acknowledge Dr. Frantisek Franek <franek@mcmaster.ca> for the adminstration of the capstone course.\\

\section*{BSD 2-Clause License}
Copyright (c) 2020 Emily Horsman, Tanner Ryan. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
\begin{enumerate}
\item Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

\item Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
\end{enumerate}

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\newpage

\tableofcontents

\section*{Revision History}
\begin{figure}[H]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Date}     & \textbf{Version} & \textbf{Description}                                                                                                                                                                                                                                                                                                                  & \textbf{Author(s)}                                                   \\ \hline
November 2, 2019  & 1.0              & Initial document.                                                                                                                                                                                                                                                                                                                     & \begin{tabular}[c]{@{}l@{}}Emily Horsman,\\ Tanner Ryan\end{tabular} \\ \hline
November 6, 2019  & 1.1              & \begin{tabular}[c]{@{}l@{}}Extend project background,\\ system overview.\end{tabular}                                                                                                                                                                                                                                                 & Emily Horsman                                                        \\ \hline
December 31, 2019 & 2.0              & \begin{tabular}[c]{@{}l@{}}Add software design specification,\\ architecture.\end{tabular}                                                                                                                                                                                                                                            & \begin{tabular}[c]{@{}l@{}}Emily Horsman,\\ Tanner Ryan\end{tabular} \\ \hline
April 29, 2020    & 2.1              & \begin{tabular}[c]{@{}l@{}}Update network protocols to\\ reflect changes in implementation.\\ \\ Minor corrections to software design\\ specification.\\ \\ Add requested viewpoints: interface,\\ structure, interaction, resource.\\ \\ Add user (application) interface\\ specifications.\\ \\ Add programming guide.\end{tabular} & \begin{tabular}[c]{@{}l@{}}Emily Horsman,\\ Tanner Ryan\end{tabular} \\ \hline
April 30, 2020    & 2.2              & \begin{tabular}[c]{@{}l@{}}Add API interface information.\\ \\ Finalize code guide.\\ \\ Update viewpoints.\end{tabular} & \begin{tabular}[c]{@{}l@{}}Emily Horsman,\\ Tanner Ryan\end{tabular} \\ \hline
\end{tabular}
\end{figure}
\newpage

\section*{Software Requirements Specification}

\section{Introduction}
This document is to describe the system architecture of \name.
Defined immediately below are terms referenced within this document.

Emily Horsman and Tanner Ryan are responsible for this aspect of the project.

\section{Definitions}

\begin{enumerate}
\item \proto: Inter-Integrated Circuit, a standardized, packet switched serial bus. Allows for bidirectional communication between hardware peripheral and microcontrollers.
\item Microcontroller: Arduino powered, single board computer. Provides an I2Cbus and IP network connection.
\item Controller: main application server for Telemetry. Responsible for communication with microcontroller(s), exposing HTTP API service, Websocket service, and serving the dashboard.
\item Peripheral processor: responsible for informing the controller how a sensor model works via Telemetry’s external interface.
\item Peripheral: Any \proto\ hardware sensor (e.g. temperature, accelerometer, thermal cam- era) which uses the \proto\ standard “register paradigm”.
\item HTTP API: application programming interface, a publicly exposed HTTP endpoint to provide a defined request-response messaging system. 
\item Peripheral payload: Raw data originating from a peripheral.
\item Peripheral data: List of key-values derived from peripheral payload.
\item Frame payload: Data sent between a microcontroller and a controller.
\end{enumerate}

\section{Context}
\proto is an existing bus protocol which enables hardware peripherals to communicate with each other and devices such as microcontrollers.
Currently, repetitive application logic must be written for each \proto device.
This application logic is hard to write in a maintainable, self-documenting way.
Any modification of the application logic means that firmware updates need to be applied to other devices on the \proto bus (most commonly, the microcontroller serving as the ``master'' device).
This creates a significant amount of work throughout the prototyping and maintenance stages of a hardware project.

\section{System Overview}
\name\ is a proposed software solution to abstract the most common usages of the \proto\ protocol.
This layer of abstraction allows the end user to rapidly provision microcontrollers for the ingestion of peripheral data.
\name\ will provide the user with a Websocket stream and a HTTP API for the configuration of peripherals and the consumption of peripheral data.

\section{Project Goals}

This version of \name\ will support the following features.

\subsubsection{Websocket stream}
\name\ will expose a standard Websocket stream to allow for real-time integration of peripheral data into an existing application.

\subsubsection{HTTP API}
\name\ will expose an HTTP API that allows for the querying of current and past data.
This provides users with a non real-time data source for integration with legacy applications.

\subsubsection{Microcontroller and Peripheral Autodiscovery}
\name\ provides the user with an Arduino library and a containerized controller.
The library is be responsible for:
\begin{enumerate}
\item Initializing and re-establishing a connection to the controller.
\item Autodiscovery of \proto\ peripherals.
\item Collection and forwarding of peripheral payloads to controller.
\end{enumerate}

The controller is responsible for providing the Websocket stream and HTTP API, which the user will interact with.

\section{Non-project Goals}

This version of \name\ will not support the following features.

\subsection{Multitenancy}
The controller of \name\ is designed around the requirements of an individual or single organization. 
No user authentication is performed.

\subsection{End-to-End Encryption}
All frame payloads sent between microcontrollers and the controller are over plaintext.
Frame payloads must not contain confidential information.

\section{Design Considerations}

\subsection{Assumptions and Dependencies}

\subsubsection{Software and Hardware}
This version of \name's microcontroller library will only support Arduino-compatible platforms.
The Arduino ESP32 microcontroller will have tested hardware support.

\subsubsection{Operating Systems}
The controller will be packaged using Docker, a containerization platform.
Therefore, the controller will be compatible with all operating systems that support Docker.
Linux and macOS will have tested software support.

\subsection{General Constraints}

\subsubsection{Network Connectivity}
\name\ will have the ability to work well on low bandwidth, high latency networks.
Although the microcontrollers are capable of re-establishing a connection with the controller, the network should have minimal packet loss for real-time data consumption.\\

Microcontrollers are not required to be on the same network as the controller, although the controller must be reachable from the microcontroller's network.

\section{System Design}

All \textbf{bold} keywords refer to definitions or architecture components.

\subsection{Architecture}

The following depicts a \name\ setup with two \textbf{microcontrollers} and three \textbf{peripheral processors}.

\begin{figure}[H]
  \includegraphics[width=\linewidth]{architecture.png}
  \caption{System Architecture}
  \label{fig:architecture1}
\end{figure}

\subsubsection{\proto\ Peripheral}
A hardware sensor that utilizes the \proto\ ``register paradigm''.
Connected to the \textbf{microcontroller} through direct hardwired connection.

\subsubsection{Microcontroller}
An Arduino powered computer.
Responsible for establishing hardware connection with \textbf{peripheral(s)}.
The microcontroller will run \name's Arduino library.

\subsubsection{MQTT Broker}
Responsible for exposing an MQTT server, a lightweight publish/subscribe message transport protocol.
The \textbf{microcontroller(s)} and the \textbf{processor} are responsible for establishing an MQTT connection.
The \textbf{microcontroller(s)} will re-establish the MQTT connection in the event that the connection is interrupted.


\subsubsection{Controller}
Main event engine for Telemetry.
The interfacing is broken down into four categories:\\

\textbf{MQTT Interfacing}:
\begin{enumerate}
\item Receive registration messages (\textbf{frame payload}) from \textbf{microcontroller(s)} over MQTT.
\item Receive \textbf{peripheral payloads} from \textbf{microcontroller(s)} over MQTT.
\item Publish provisioning message (\textbf{frame payload}) to \textbf{microcontroller(s)} over MQTT.
\item Publish one-off messages (\textbf{frame payload}) to \textbf{microcontroller(s)} over MQTT (i.e. reboot, manually poll data).
\end{enumerate}

\textbf{AMQP Interfacing}:
\begin{enumerate}
\item Publish raw \textbf{peripheral payloads} over AMQP.
\item Receive \textbf{peripheral data} over AMQP.
\end{enumerate}

\textbf{SQL Database Interfacing}:
\begin{enumerate}
\item Insert \textbf{peripheral data}.
\item Insert/update/delete \textbf{microcontroller} configuration.
\item Query \textbf{peripheral data}.
\end{enumerate}

\textbf{Web Server Interfacing}:
\begin{enumerate}
\item Expose HTTP endpoints for REST \textbf{API}.
\item Expose websocket connection for real-time streaming updates.
\end{enumerate}

\subsubsection{SQL Database}
Responsible for persistent storage of \textbf{peripheral data}, and \textbf{microcontroller} provisioning.

\subsubsection{AMQP Broker}
Akin to MQTT Broker, responsible for exposing AMQP server, a publish/subscribe message transport protocol with queueing capabilities.
The \textbf{processor(s)} and the \textbf{controller} are responsible for establishing an AMQP connection.
The \textbf{processor(s)} will re-establish the AMQP connection in the event that the connection is interrupted.

\subsubsection{Peripheral Processor}
An individual \textbf{peripheral processor} is required per \textbf{peripheral} type (i.e. Adafruit temperature sensor).
It must establish an AMQP connection with \name's AMQP broker.
The \textbf{processor} will advertise the type of \textbf{peripheral} that it can process.
It will then receive raw \textbf{peripheral payloads} over AMQP that match the peripheral type.
The processor will parse the raw data into value(s), publishing the \textbf{peripheral data} over AMQP.

\subsubsection {Web Server}
Responsible for performing SSL (TLS) termination for the \textbf{dashboard}, \textbf{Websocket}, and HTTP \textbf{API} services.

\subsubsection{Websocket}
\textbf{Websocket stream} that user may interact with, satisfying project goals.

\subsubsection{HTTP API}
HTTP \textbf{API} that user or scripts may interact with, satisfying project goals. 

\subsection{Transport Protocol}
All data transmitted over the \textbf{transport layer} will be using a custom wire (binary) format over MQTT.
The following transactions are supported by \name's protocol.

\subsubsection{Registration Frame}
A \textbf{microcontroller} must send a registration frame when:
\begin{enumerate}
\item MQTT connection is established.
\item MQTT connection is re-established after disconnection.
\item A \textbf{peripheral} was connected or disconnected.
\end{enumerate}

The registration frame contains:
\begin{enumerate}
\item \name\ Arduino library version identifier.
\item \textbf{Microcontroller} unique identifier (MAC address).
\item \textbf{Microcontroller} network IP address.
\item List of \textbf{peripherals} (active \proto\ addresses).
\end{enumerate}

The registration frame is used for provisioning of \textbf{microcontrollers}.
This provisioning builds a registry of all \textbf{microcontrollers} and \textbf{peripherals} connected to \name.

\subsubsection{Payload Frame}
A \textbf{microcontroller} must send a payload frame when:
\begin{enumerate}
\item Raw data is collected from \textbf{peripheral}.
\end{enumerate}

The payload frame contains:
\begin{enumerate}
\item \textbf{\proto} address of data collection.
\item Raw \textbf{peripheral payload}.
\end{enumerate}

The payload frame is used for sending raw data from \textbf{peripheral(s)} to the \textbf{controller}.

\subsubsection{Provisioning Frame}
A \textbf{controller} must send a provisioning frame when:
\begin{enumerate}
\item A \textbf{registration frame} is received.
\item The provisioning of a \textbf{microcontroller} has been modified.
\end{enumerate}

The provisioning frame contains:
\begin{enumerate}
\item \textbf{Microcontroller} schedule.
\end{enumerate}

The provisioning frame is used for dynamically assigning the \textbf{microcontroller} a schedule.
This schedule identifies \textbf{\proto} addresses to poll, the polling format, and the polling interval.
The \textbf{microcontroller} will continuously run this schedule, publishing \textbf{payload frames} as data is collected.
If a new \textbf{provisioning frame} is received by a \textbf{microcontroller}, the new schedule is to be utilized.

\subsubsection{Request Frame}

A \textbf{controller} must send a request frame when:
\begin{enumerate}
\item The user requests the \textbf{microcontroller} to reboot.
\item The user requests the \textbf{microcontroller} to manually perform one iteration of the \textbf{schedule}.
\end{enumerate}

The request frame contains:
\begin{enumerate}
\item Action for \textbf{microcontroller} to perform.
\end{enumerate}

The request frame is used for notifying the \textbf{microcontroller} to perform one-off events.
The requests are activated by the user.
This is for debugging purposes.

\subsection{Processor Protocol}
All data transmitted over the \textbf{processor layer} will be JSON over AMQP.

\subsubsection{AMQP Initialization}
A \textbf{peripheral processor} will interface with \name\ by initializing an AMQP connection with the \textbf{AMQP broker}.
When the connection is established, the \textbf{peripheral processor} must subscribe to the \texttt{controller.addr.\#} route, where \texttt{addr} is replaced with the \textbf{peripheral} bus address which this processor is capable of parsing.
The \textbf{peripheral processor} must also subscribe to \texttt{global.req} for listening to configuration requests.

\textbf{Peripheral payloads} matching the \textbf{peripheral} bus addressed will be pushed to this processor.
If multiple \textbf{peripheral processors} of the same bus address are connected, \textbf{peripheral payloads} will be distributed in a round-robin fashion.

\subsubsection{Consume Peripheral Payload}
When new data is collected from a \textbf{peripheral} with bus address \texttt{x}, connected to a microcontroller with MAC address \texttt{y}, the raw \textbf{peripheral payload} will be received on a \textbf{peripheral processor} subscribed to \texttt{controller.x.y}.
The \textbf{peripheral processor} must convert the raw, often proprietary, \textbf{\proto} data into a list of key and values, that can be ingested by \name.

The incoming data will be in the following JSON format:

\begin{minted}[breaklines,frame=single]{json}
{
  "busId": 1,
  "busAddr": 68,
  "data": "MjAyMC0wNC0yOVQwMjoxMToyNFo="
}
\end{minted}

The \texttt{busId} and \texttt{busAddr} will be modified accordingly.
The \texttt{data} field is the base64 representation of the raw data collected from the peripheral.
This raw data must be converted into a set of key-values and published as described below.

The \textbf{peripheral processor} may be written in any language.
The only requirement is that the language must have support for AMQP and JSON.

\subsubsection{Publish Peripheral Data}
When the \textbf{peripheral processor} has generated a JSON object of keys and values, the JSON data will be published over AMQP with a routing key of \texttt{data.x.y}, where both \texttt{x} and \texttt{y} are equal to the variables during \textbf{peripheral payload} consumption.\\

\name\ will insert this data into the database, making it available on the \textbf{Websocket} and HTTP \textbf{API} service.

\subsubsection{Configuration Advertisement}
On \textbf{peripheral processor} initialization, and when an empty message is received on the \texttt{global.req} route, the configuration profile must be published on the \texttt{global.config} route.
The configuration profile must be in the following JSON format:

\begin{minted}[breaklines,frame=single]{json}
{
  "busAddr": 0,
  "name": "",
  "readDefinitions": [
    {
      "definitionId": 0,
      "registerIdLength": 0,
      "registerId": 0,
      "registerBlockLength": 0,
      "numBytesPerRegister": 0,
      "readPeriod": 0
    }
  ]
}
\end{minted}

Replace above variables as described in a \textbf{peripheral's} specification document.
If a \textbf{peripheral} does not have this information available, it is considered incompatible with \name.

\subsection{Application Protocol}
The standard REST API pattern is to be utilized for the HTTP \textbf{API} service. 
All data requested and returned by \textbf{API} is to be in valid JSON format.

\section{Languages and Frameworks}

\subsection{Frontend: React}
React is an open source JavaScript framework, allowing for the creation of interactive, modular user interfaces.
React allows us to write a lightweight user interface in a declarative fashion with modern functional-style JavaScript.
Typed JavaScript has good support for React.
The React community offers many well-written open-source ``batteries'' for data visualization that will aide in a rapid development process.

\subsection{Transport Layer: MQTT}
MQTT is a low-overhead messaging protocol.
MQTT enables \name\ to reliably and efficiently collected data from remote Arduino \textbf{microcontrollers}.
It ensures that data sent between \textbf{microcontroller(s)} and the \textbf{controller} is delivered.
Such delivery reports are essential on networks that contain packet loss.\\

VerneMQ is an open source, industry standard MQTT broker.

\subsection{Processor Layer: AMQP}
AMQP is very similar to MQTT, except for the addition of queuing capabilities.
Message queuing is used for \name\ to process \textbf{peripheral payloads} in a distrbuted manner.
AMQP also allows \name\ to have interoperability with many programming languages, allowing for \textbf{peripheral processors} to be language agnostic.\\

RabbitMQ is an open source, industry standard AMQP broker.

\subsection{Application Layer: JSON}
JSON is a human-readable, object encoding format.
It is an industry standard format utilized in web applications.

\subsection{Controller: Go}
Go is statically typed, memory safe programming language.
Go was chosen for the following features:
\begin{enumerate}
\item Type checking.
\item Memory safety.
\item Low-overhead runtime.
\item High performance networking.
\item Concurrency via message passing.
\end{enumerate}

Utilizing Go, \name\ will be lightweight, performant, and reliable.

\section{Scenarios}

\subsection{New Peripheral Connected}

The following will occur when a new peripheral is connected to a microcontroller.

\begin{enumerate}
\item User connects new \textbf{peripheral}.
\item \textbf{Microcontroller} detects new device, sends \textbf{registration frame}.
\item \textbf{Controller} receives \textbf{registration frame}, creates a new inactive device record in the \textbf{database}.
\item The \textbf{controller} will send a \textbf{provisioning frame} to the corresponding \textbf{microcontroller}, specifying the new schedule.
\item \textbf{Microcontroller} stores the new schedule in volatile memory (RAM).
\item When data from the \textbf{peripheral} becomes available, it will become accessible on the \textbf{Websocket} and \textbf{API} for data viewing.
\end{enumerate}

\subsection{Normal Scheduling Operation}

The following is the main event loop that occurs under normal operation.

\subsubsection{Microcontroller}

The event loop will be preempted if the \textbf{microcontroller} receives a \textbf{provisioning frame} or \textbf{request frame} sent from the \textbf{controller}.

\begin{enumerate}
\item \textbf{Microcontroller} reads schedule from volatile memory (RAM).
\item \textbf{Microcontroller} will iterate over the list of provisioned \textbf{peripherals}:
  \begin{enumerate}
  \item If there exists a previous read for an \proto\ address and a new reading is not required yet, skip the \textbf{peripheral}.
  \item If there exists a previous read for an \proto\ address and a new reading is required, or if a previous reading does not exist, perform collection transaction. After the raw \textbf{peripheral payload} is collected, publish the data over MQTT in a \textbf{payload frame}.
  \end{enumerate}
\item Repeat.
\end{enumerate}

\subsubsection{Controller}

The controller will run this event loop while concurrently responding to HTTP requests for the \textbf{Websocket} and \textbf{API} services.

\begin{enumerate}
\item \textbf{Controller} receives \textbf{payload frame} from \textbf{microcontroller}, containing raw \textbf{peripheral payload}.
\item \textbf{Controller} publishes raw \textbf{peripheral payload} over AMQP.
\item \textbf{Processor} consumes raw \textbf{peripheral payload} over AMQP. \textbf{Processor} parses raw \proto\ data into a list of JSON-encoded key-values (\textbf{peripheral data}). \textbf{Processor} publishes \textbf{peripheral data} over AMQP.
\item \textbf{Controller} consumes JSON-encoded \textbf{peripheral data} from AMQP. \textbf{Controller} inserts data into database and publishes data over websocket.
\end{enumerate}

\section*{Software Design Description}

\section{Interface viewpoint}
\name\ does not provide a graphical user interface.
The primary interface is through the \textbf{Websocket} and \textbf{API} interfaces.
\footnote{The final submission does include a sample GUI which utilizes the WebSocket interface. However this is not a primary requirement.}

\subsection{Websocket Interface}
When \name\ is deployed, the Websocket interface is accessible on \texttt{/api/ws}.
The Websocket stream will emit frames in real-time as \textbf{peripheral} data is sent from \textbf{microcontrollers}.
The Websocket frame will be a JSON payload in the following format:

\begin{minted}[breaklines,frame=single]{json}
{
  "uuid": "",
  "busAddr": 0,
  "timestamp": "",
  "data": {}
}
\end{minted}

The \texttt{uuid} filed will match the MAC address of the \textbf{microcontroller}, and the \texttt{busAddr} field will match the bus address of the \textbf{peripheral} where the data was collected.
The \texttt{timestamp} is an RFC3339 timestamp of when the data was received on the \textbf{controller}.
The \texttt{data} field contains a standard JSON object.
This object will contain the JSON output from the \textbf{peripheral processor}.

The following is an example of a Websocket frame:

\begin{minted}[breaklines,frame=single]{json}
{
  "uuid": "807d3abcad84",
  "busAddr": 68,
  "timestamp": "2020-04-30T02:29:00Z",
  "data": {
    "denominator": 100,
    "humidity": 4790,
    "temp": 2464
  }
}
\end{minted}

Multiple subscribers may bind to the Websocket interface at once.

\subsection{API Interface}
The HTTP API exposes three endpoints for accessing \name\ data.

\subsubsection{/api/microcontroller}
The microcontroller interface returns a list of connected microcontrollers and their connected peripherals.

\textbf{Request}
\texttt{GET /api/microcontroller}

No query parameters shall be provided in the request.

\textbf{Response}
200 OK (Content-type: application/json)
\begin{minted}[breaklines,frame=single]{json}
[
  {
    "uuid": "807d3abcad84",
    "firmware": 1,
    "ipv4": "192.168.1.9",
    "ipv6": "00:00:00:00:00:00:00:00",
    "peripherals": [
      {
        "busId": 1,
        "busAddr": 68,
        "callResp": ""
      }
    ]
  }
]
\end{minted}

\subsubsection{/api/provisioning}
The provisioning interface returns a list of peripheral provisioning profiles.
These profiles are populated by the peripheral processors.

\textbf{Request}
\texttt{GET /api/provisioning}

No query parameters shall be provided in the request.

\textbf{Response}
200 OK (Content-type: application/json)

\begin{minted}[breaklines,frame=single]{json}
[
  {
    "busAddr": 68,
    "name": "SHT31",
    "definitionId": 1,
    "regIdLength": 0,
    "regId": 9216,
    "regBlockLength": 1,
    "bytesPerReg": 6,
    "readPeriod": 1000
  }
]
\end{minted}

\subsubsection{/api/data}
The data interface returns the processed peripheral data.
The endpoint requires a microcontroller UUID and a bus address to be provided.
Optionally, a start and/or stop parameter may be provided to filter peripheral data by time.

\textbf{Request}
\texttt{GET /api/data?uuid=\&busAddr=}

Parameters:
\begin{itemize}
\item[1.] [Required] \texttt{uuid}: Microcontroller UUID (MAC address) where data originates from.
\item[2.] [Required] \texttt{busAddr}: Bus address where data originates from.
\item[3.] [Optional] \texttt{start}: RFC3339 start time. Returns data collected after this timestamp.
\item[4.] [Optional] \texttt{stop}: RFC3339 stop time. Returns data collected before this timestamp.
\end{itemize}

If a required parameter is missing, or if a optional parameter is not correctly formatted, an error will be returned.

Example API call:
\texttt{/api/data?uuid=807d3abcad84\&busAddr=68\\\&start=2020-04-30T02:29:15Z\&stop=2020-04-30T02:29:17Z}

\textbf{Response}
200 OK (Content-type: application/json)

\begin{minted}[breaklines,frame=single]{json}
[
  {
    "uuid": "807d3abcad84",
    "busAddr": 68,
    "timestamp": "2020-04-30T02:29:15Z",
    "data": {
      "denominator": 100,
      "humidity": 4795,
      "temp": 2460
    }
  },
  {
    "uuid": "807d3abcad84",
    "busAddr": 68,
    "timestamp": "2020-04-30T02:29:16Z",
    "data": {
      "denominator": 100,
      "humidity": 4792,
      "temp": 2460
    }
  },
  {
    "uuid": "807d3abcad84",
    "busAddr": 68,
    "timestamp": "2020-04-30T02:29:17Z",
    "data": {
      "denominator": 100,
      "humidity": 4798,
      "temp": 2460
    }
  }
]
\end{minted}

Akin to the Websocket interface, the \texttt{data} field will contain the JSON output from the \textbf{peripheral processor}.

\section{Structure viewpoint}

\subsection{C++ package hierarchy}

\includepdf[pages=-]{../prototypes/latex/main_8cpp__incl.pdf}

\subsection{Go package hierarchy}
The diagram describes the programming structure of \name's controller.
Bold nodes denote the functions executed when the program executes.
Red lines denote local packages dependant of global state, stored in \texttt{state} package.
Green lines denote local packages dependant of the database interface, stored in \texttt{db} package.
Blue nodes denote third party packages.

\includepdf[pages=-]{../backend/latex/packages.pdf}

\subsection{PostgreSQL relation hierarchy}
All data for \name\ is stored utilizing the following schema.

\begin{figure}[H]
  \includegraphics[width=\linewidth]{uml.png}
  \caption{SQL UML Diagram}
  \label{fig:uml}
\end{figure}

\section{Interaction viewpoint}
The diagram below describes the system interaction during nominal operation.
No message loss is present.
The blue depicts primary data flow.
The red depicts delivery reports.

\begin{figure}[H]
  \includegraphics[width=\linewidth]{interaction.png}
  \caption{Interaction viewpoint, nominal operation}
  \label{fig:uml}
\end{figure}

In the event that message loss is present, indicated by the lack of acknowledgement messages, the originating sender will attempt to resend the data until acknowledgements are again received.
If the buffer of acknowledged messages exceeds available memory constraints of the ESP32 microcontroller, the oldest unacknowledged message will be dropped.

\section{Algorithm viewpoint}
There are no applicable algorithmic viewpoints for \name.

\section{Resource viewpoint}
There are no applicable resource viewpoints for \name.
\newpage

\section{Code Guide}

\subsection{Preamble}

Emily Horsman and Tanner Ryan are responsible for this aspect of the project.

All development was done with version control and shared via GitHub: \url{https://github.com/emilyhorsman/4zp6}

\subsection{Hardware/Software Requirements}

Language Summary: C++, Go, Haskell, JavaScript, Python

\subsubsection{Hardware}

\begin{enumerate}
    \item An ESP32 or other Arduino-compatible microcontroller. We used a HUZZAH32 from Adafruit during development. \url{https://www.adafruit.com/product/3405}
\item \proto based sensors. We used an SHT31, LIS3DH, TCS34725, and AMG8833 during development to ensure our protocol works on a wide variety of sensors.
\end{enumerate}

\subsubsection{Microcontroller Firmware}

\begin{enumerate}
\item C++11. This is the primary language the firmware is written in.
\item PlatformIO. This is a development toolchain to target the embedded hardware. \url{https://platformio.org}
\item nanopb v0.3.9.5. An implementation of Protocol Buffers designed for embedded systems. Included in this repository under \texttt{prototypes/lib/Nanopb}. \url{https://jpa.kapsi.fi/nanopb/}
\item MQTT Arduino Client. \url{https://github.com/knolleary/pubsubclient/}
\item Python 3.6. There is some rudimentary templating performed at compile-time for the provisioning web server running on the microcontroller. \url{https://www.python.org}
\end{enumerate}

\subsubsection{Protocol and Networking}

\begin{enumerate}
\item \texttt{protoc} to compile and test Protocol Buffer schemas/messages. \url{https://developers.google.com/protocol-buffers}
\item VerneMQ. This is an MQTT broker. \url{https://vernemq.com}
\item RabbitMQ. This is an AMQP broker. \url{https://www.rabbitmq.com}
\item Docker. The backend, database, web server, and brokers are all provisioned with a Docker configuration file: \texttt{backend/Dockerfile}. \url{https://www.docker.com}
\end{enumerate}

\subsubsection{Backend}

\begin{enumerate}
\item Go v1.14.2. This is the primary language the backend is written in. \url{https://golang.org}
\item Caddy v2. This is a web server which fronts the Go application server. \url{https://caddyserver.com}
\item PostgreSQL v12. Data from micro controllers is logged to a Postgres database. \url{https://www.postgresql.org}
\item paho.mqtt.golang v1.2.0 \url{https://github.com/eclipse/paho.mqtt.golang}
\item mux v1.7.4 \url{https://github.com/gorilla/mux}
\item websocket v1.4.2 \url{https://github.com/gorilla/websocket}
\item godotenv v1.3.0 \url{https://github.com/joho/godotenv}
\item pq v1.3.0 \url{https://github.com/lib/pq}
\item go.uuid v1.2.0 \url{https://github.com/satori/go.uuid}
\item logrus v1.4.2 \url{github.com/sirupsen/logrus}
\item amqp v0.0.0-20200108173154-1c71cc93ed71 \url{https://github.com/streadway/amqp}
\item protobuf v1.21.0 \url{https://google.golang.org/protobuf}
\end{enumerate}

\subsubsection{Peripheral Processors}

\begin{enumerate}
\item Haskell 2010. Peripheral processors can be written in any language with an AMQP library. This repo provides an example processor writte in Haskell (\texttt{sht31-controller/}) and includes a support library for other processors written in Haskell. \url{https://www.haskell.org}
\item Cabal to install Haskell dependencies in a standard way. \url{https://www.haskell.org/cabal/}
\item Aeson v1.4. \url{https://hackage.haskell.org/package/aeson}
\item base64-bytestring v1.1. \url{https://hackage.haskell.org/package/base64-bytestring}
\item AMQP client v0.19. \url{https://hackage.haskell.org/package/amqp}
\end{enumerate}

\subsubsection{Dashboard}

\begin{enumerate}
\item JavaScript following modern ECMA standards is the primary language the dashboard is written in (along with HTML/CSS). One only needs a modern evergreen browser.
\item \texttt{npm} to install JavaScript packages. \url{https://www.npmjs.com}
\item React v16. \url{https://reactjs.org}
\item React Victory v34. \url{https://formidable.com/open-source/victory/}
\end{enumerate}

\subsection{Completed Features and Details}
\label{sec:features}

\begin{enumerate}
\item An abstraction for generalizing \proto sensors. This is reflected in the architecture of the entire repository. A primary artifact with detailed comments can be found in \texttt{protocol/telemetry.proto}. This is a Protocol Buffers definition for messages that generalize the behaviour of \proto sensors. A processor such as the one found in \texttt{sht31-controller/} can then specify the interaction with a sensor in a declarative fashion --- without writing new application logic or physically updating firmware. The low-level task of reading from the bus and understanding the sensors' protocol is decoupled from processing the data.
\item A REST API for retrieving logged data from sensors and connectivity information. Includes various filters such as time ranges. \texttt{backend/controller/api/api.go}
\item A WebSocket API to allow web browsers to receive data in real-time without polling an API. \texttt{backend/controller/api/websocket.go}
\item A database for logging retrieved data and microcontroller provisioning. \texttt{backend/controller/db/init.go}
\item Docker configuration to provision the web server, database, and brokers. \texttt{backend/Dockerfile}
\item A sample processor written in Haskell to decouple application logic involved in using \proto peripherapls. This includes a support library for other processors written in Haskell to use. \texttt{sht31-controller/}
\item A sample web application which uses WebSockets to display data from a sensor in real-time. \texttt{dashboard/src/App.js}
\item Automatic discovery of \proto sensors when they are physically connected or disconnected. \texttt{prototypes/src/I2CManager.cpp}
\item A generic non-blocking scheduler using modern C++11. \texttt{prototypes/src/Scheduler.cpp}
\item A web application served by the microcontroller to allow a user to configure data without changing the firmware. This data persists on reboot. \texttt{prototypes/src/WiFiProvisioning.cpp}
\item A runtime on the microcontroller for generalizing \proto behaviour with declarative configurations. \texttt{prototypes/src/I2CRuntime.cpp}
\end{enumerate}

\subsection{A Tour of the Simplest Case}

Below is a description of the components involved in the simplest task of Telemetry: reading data from a sensor connected to a microcontroller, storing it in a database, and serving it through a REST and WebSockets API.
The primary feature of Telemetry is the architecture that allows \proto peripherals to be generalized and used without custom application logic.
The following tour is only showing one path of what this architecture allows.
It is a limited view that aims to highlight aspects of the codebase and how it works together --- not the entire scope of the project.

\begin{enumerate}
\item A microcontroller running the Telemetry firmware is powered on.
\item It broadcasts a WiFi access point and serves a web application.
    This allows users to provision the microcontroller with network connection information without needing to hard-code values in firmware and have physical access to the microcontroller.
    \texttt{prototypes/src/WiFiProvisioning.cpp}
\item A user provisions the microcontroller and the microcontroller connects to the given WiFi access point.
\item A sensor is plugged into the microcontroller.
    The sensor is automatically discovered.
    The Telemetry firmware consists of an event loop and state machine which poll the \proto bus for peripherals connecting and disconnecting --- \texttt{prototypes/src/I2CManager.cpp}.
    It also manages the firmware's multiple tasks by loosely emulating threads --- the microcontroller is not running an operating system that gives threads.
    We wrote a generic scheduler: \texttt{prototypes/src/Scheduler.cpp}.
\item A message is sent to the backend through the MQTT broker describing the connected sensor.
    \texttt{prototypes/src/MQTTManager.cpp}, \texttt{prototypes/src/TelemetryProtocol.cpp}
\item The backend asks the online processors if any are responsible for the described sensor.
\item The responsible processor sends a declarative configuration for the sensor to the AMQP broker.
\item The backend delivers this to the appropriate microcontroller through the MQTT broker.
\item The firmware's runtime stores this configuration and will use it to poll data from the sensor.
        \texttt{prototypes/src/I2CRuntime.cpp}
\item The microcontroller reads data from the \proto bus and sends the raw bytes to the backend through MQTT.
\item The backend proliferates this to the appropriate processor through AMQP.
\item The processor converts the raw bytes to semantically correct data (such as a temperature value).
    \texttt{sht31-controller/Main.hs}
\item The processor sends this data to the backend through AMQP. \texttt{sht31-controller/Support.hs}
\item The backend writes this data to the database. \texttt{backend/controller/db/}
\item The backend pushes this new data to any open WebSocket connections. \texttt{backend/controller/api/websocket.go}
\item A dashboard with an open WebSocket connection reads this message and graphs the data over time.
    \texttt{dashboard/src/App.js}
\end{enumerate}

\subsection{Statistics}

Using the tool \texttt{sloc} to quantify `significant' lines of code:

\begin{verbatim}
> sloc --exclude 'binary|docs|.*\.pio.*|.*vendor.*|Nanopb|.*node_modules.*' .

---------- Result ------------

  Physical :  5674
    Source :  4140
   Comment :  974
\end{verbatim}

\section{Appendix}

\subsection{Telemetry Protobuf Definition}

\begin{minted}[breaklines,frame=single]{protobuf}
// BSD 2-Clause License
//
// Copyright (c) 2020 Emily Horsman, Tanner Ryan. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

syntax = "proto3";
option go_package = ".;telemetry";
import "nanopb.proto";

/**
 * Telemetry wire protocol for MQTT communication between microcontrollers and the backend.
 */
message Telemetry {
    /**
     * Type of frame message encoded.
     */
    Message message = 1;
    enum Message {
        ZERO = 0;
        REGISTRATION = 1;
        PROVISIONING = 2;
        PAYLOAD = 3;
        REQUEST = 4;
    }

    /**
     * Registration frame notifes backend of microcontroller firmware, IP addresses, and connected peripherals.
     */
    Registration registration = 2;

    /**
     * Provisioning frame provides microcontroller with peripheral read definitions.
     */
    Provisioning provisioning = 3;

    /**
     * Payload frame provides backend with raw peripheral byte data collected from microcontrollers.
     */
    Payload payload = 4;

    /**
     * Request frame notifes microcontroller to perform one-off requests.
     */
    Request request = 5;
}

/**
 * Registration frame (microcontroller -> backend).
 *
 * The microcontroller UUID (MAC address) will be sent in the MQTT topic.
 *
 * Conditions:
 *  - MQTT connection established, re-established
 *  - Peripheral connected, disconnected
 */
message Registration {
    /**
     * Firmware version identifier.
     */
    uint32 version = 1;

    /**
     * Microcontroller unique identifier (MAC address).
     */
    string uuid = 2 [(nanopb).max_size = 13];

    /**
     * Microcontroller IPv4 address.
     */
    string ipv4 = 3 [(nanopb).max_size = 16];

    /**
     * Microcontroller IPv6 address.
     */
    string ipv6 = 4 [(nanopb).max_size = 40];

    /**
     * List of connected peripherals.
     */
    repeated Peripheral peripherals = 5;
    message Peripheral {
        /**
         * The I2C bus this peripheral is connected to on the microcontroller. Represented by the SDA line pin.
         */
        uint32 busId = 1;

        /**
         * The I2C bus address this peripheral is connected to on the microcontroller.
         */
        uint32 busAddr = 2;

        /**
         * I2C general call response.
         */
        bytes generalCallResp = 3;
    }
}

/**
 * Provisioning frame (backend -> microcontroller).
 *
 * Conditions:
 *  - Received Registration frame from microcontroller.
 *  - Received new read definitions from corresponding peripheral controller.
 */
message Provisioning {
    /**
     * Default bus address for peripheral.
     */
    uint32 busAddr = 1;

    /**
     * Display name of peripheral processor, displayed on dashboard.
     */
    string name = 2;

    /*
     * Peripheral read definitions.
     */
    repeated ReadDef readDefinitions = 3;
    message ReadDef {
        /**
         * An arbitrary ID for external reference. This does not relate to the
         * hardware or any application logic in the I2CRuntime. This is used
         * externally to track read definitions.
         */
        uint32 definitionId = 1;

        /**
         * Some peripherals have 16-bit register IDs and some have 8-bit register
         * IDs.
         */
        RegLength registerIdLength = 2;
        enum RegLength {
            RL16 = 0;
            RL8 = 1;
        }

        /**
         * Data is read on this output from a contiguous block of register IDs.
         * e.g., 0x80 to 0xFF. This is the first register ID of the block.
         */
        uint32 registerId = 3;

        /**
         * Data is read on this output from a contiguous block of register IDs.
         * e.g., 0x80 to 0xFF. This defines the number of register IDs in the block.
         * This is essentially how many times the loop will read bytes at a register
         * and then advance to the next register. For many peripherals this value is
         * simple 1 (i.e., there is no need to advance).
         */
        uint32 registerBlockLength = 4;

        /**
         * The number of bytes that will be read at each register ID in the
         * contiguous block. This means that the total number of bytes retrieved
         * from one ReadDefinition instance is:
         * 
         *     numBytesPerRegister * registerBlockLength
         */
        uint32 numBytesPerRegister = 5;

        /**
         * How many milliseconds between reading all bytes from the block of
         * registers?
         */
        uint32 readPeriod = 6;
    }
}

/**
 * Payload frame (microcontroller -> backend).
 *
 * The microcontroller UUID (MAC address) will be sent in the MQTT topic.
 *
 * Conditions:
 *  - Data collected from peripheral.
 */
message Payload {
    /**
     * I2C bus ID payload was collected from.
     */
    uint32 busId = 1;

    /**
     * I2C bus address payload was collected from.
     */
    uint32 busAddr = 2;

    /**
     * Payload collection definition identifier, matching ReadDef.
     */
    uint32 definitionId = 3;

    /**
     * Contents of peripheral read.
     */
    bytes data = 4;
}

/**
 * Request frame (backend -> microcontroller).
 *
 * Conditions:
 *  - Request microcontroller to reboot.
 *  - Request microcontroller to poll peripherals, send Payload frame(s).
 *  - Request microcontroller to send heartbeat (Registration frame).
 */
message Request {
    Action action = 1;
    enum Action {
        /**
         * Request microcontroller reboot.
         */
        REBOOT = 0;

        /**
         * Request manual schedule execution and Payload frame(s).
         */
        FORCE_READS = 1;

        /**
         * Request microcontroller to rescan I2C bus and resend Registration.
         */
        FORCE_SCAN = 2;

        /**
         * Request manual Registration frame.
         */
        REQUEST_REGISTRATION = 3;

        /**
         * Request microcontroller to clear preferences stored in flash.
         */
        CLEAR_PREFERENCES = 4;
    }
}
\end{minted}
\newpage

\subsection{Telemetry Backend Documentation}

\includepdf[pages=-]{../backend/latex/godoc1.pdf}
\includepdf[pages=-]{../backend/latex/godoc2.pdf}
\includepdf[pages=-]{../backend/latex/godoc3.pdf}
\includepdf[pages=-]{../backend/latex/godoc4.pdf}
\newpage

\subsection{Telemetry Firmware Doxygen Documentation}

\includepdf[pages=-]{../prototypes/latex/refman.pdf}

\end{document}
